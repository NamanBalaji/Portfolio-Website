<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Naman Balaji</title><link>https://namanbalaji.github.io/Portfolio-Website/</link><description>Recent content on Naman Balaji</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 20 Jul 2022 20:16:20 +0530</lastBuildDate><atom:link href="https://namanbalaji.github.io/Portfolio-Website/index.xml" rel="self" type="application/rss+xml"/><item><title>SOLID Design Principles</title><link>https://namanbalaji.github.io/Portfolio-Website/blogs/solid_design/</link><pubDate>Wed, 20 Jul 2022 20:16:20 +0530</pubDate><guid>https://namanbalaji.github.io/Portfolio-Website/blogs/solid_design/</guid><description>We want to design and write software that is well engineered, decoupled, reusable, and responsive to changing requirements. Obviously, we want to avoide writing bad code. But what exactly is bad code ? Following are some of the properties of bad code :
Rigid: Is the code rigid? Does it have a straight jacket of overbearing types and parameters, that making modification difficult? Fragile: Is the code fragile? Does the slightest change ripple through the code base causing untold havoc?</description></item><item><title>Understanding Raft Consensus</title><link>https://namanbalaji.github.io/Portfolio-Website/blogs/raft/</link><pubDate>Thu, 23 Jun 2022 13:31:01 +0530</pubDate><guid>https://namanbalaji.github.io/Portfolio-Website/blogs/raft/</guid><description>In Search of an Understandable Consensus Algorithm Raft is a consensus algorithm, meaning that it is designed to facilitate a set of computers agreeing on a state of the world (more on exactly how the state of the world is represented later), even when communications between the computers in the set are interrupted (say for example, by someone accidentally unplugging a network cable that connects some of the nodes to the majority).</description></item><item><title>GFS Paper Summary</title><link>https://namanbalaji.github.io/Portfolio-Website/blogs/gfs/</link><pubDate>Sun, 19 Jun 2022 01:24:34 +0530</pubDate><guid>https://namanbalaji.github.io/Portfolio-Website/blogs/gfs/</guid><description>The Google File System (2003) - Paper Summary Why are we reading the GFS paper? Incorporates many of the recurring themes in Distributed Systems: parallel performance, fault tolerance, replication, consistency. Successful real-world design. BigTable, MapReduce built on top of GFS. Well-written systems paper - details from the application to the network. What were the main contributions of the GFS paper to the industry in 2003? Despite writing about basic ideas of distribution, sharding, fault-tolerance, the use of GFS was huge in scale (larger scale than most academic systems).</description></item><item><title>Map Reduce</title><link>https://namanbalaji.github.io/Portfolio-Website/blogs/map-reduce/</link><pubDate>Sat, 18 Jun 2022 16:48:06 +0530</pubDate><guid>https://namanbalaji.github.io/Portfolio-Website/blogs/map-reduce/</guid><description>MapReduce: Simplified Data Processing on Large Clusters MapReduce is a programming model and an associated implementation for processing and generating large data sets. Users specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs, and a reduce function that merges all intermediate values associated with the same intermediate key.
Programs written in this functional style are automatically parallelised and executed on a large cluster of commodity machines.</description></item></channel></rss>